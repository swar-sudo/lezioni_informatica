<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parson Puzzle C</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .puzzle-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 90%;
            max-width: 600px;
            min-height: 200px;
            border: 2px dashed #ccc;
            padding: 15px;
            border-radius: 8px;
            background-color: #fff;
        }

        .puzzle-piece {
            background-color: #ecf0f1;
            padding: 15px;
            border: 1px solid #bdc3c7;
            border-left: 5px solid #3498db;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s;
            border-radius: 4px;
            font-size: 1.1em;
            font-family: 'Consolas', 'Monospace';
            color: #2980b9;
        }

        .puzzle-piece:active {
            cursor: grabbing;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .puzzle-piece.dragging {
            opacity: 0.5;
            border-left-color: #e74c3c;
        }

        .drag-over {
            border-bottom: 2px solid #2ecc71 !important;
        }

        .buttons-container {
            margin-top: 30px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.1s;
            font-weight: bold;
        }

        #check-btn {
            background-color: #2ecc71;
            color: white;
        }

        #check-btn:hover {
            background-color: #27ae60;
        }

        #reset-btn {
            background-color: #e74c3c;
            color: white;
        }

        #reset-btn:hover {
            background-color: #c0392b;
        }

        .feedback {
            margin-top: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            display: none;
            font-size: 1.2em;
        }

        .feedback.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .feedback.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>

    <h1>Parson Puzzle: Programma C ðŸ’»</h1>
    <p>Trascina e rilascia le righe di codice nell'ordine corretto per creare un programma C funzionante.</p>
    <h3>Scrivi un programma in C che chieda all'utente di inserire un numero intero.</h3><br><h3>
Se il numero Ã¨ maggiore di 10 e, al contempo pari, stampa "Grande".</h3><br><h3>Altrimenti stampa "Piccolo".</h3>

    <div id="puzzle-container" class="puzzle-container">
    </div>

    <div class="buttons-container">
        <button id="check-btn">âœ… Check Solution</button>
        <button id="reset-btn">ðŸ”„ Reset Puzzle</button>
    </div>

    <div id="feedback-message" class="feedback"></div>

    <script>
        // Array con l'ordine corretto del codice
        const correctOrder = [
            "#include <stdio.h>",
            "int main()",
            "{",
            "    int numero;",
            "    printf(\"inserire un numero\");",
            "    scanf(\"%d\", &numero);",
            "    if(numero>=10)",
            "    printf(\"Grande\");",
            "    else",
            "    printf(\"Piccolo\");",
            "    return 0;",
            "}"
        ];

        // Array con l'ordine iniziale disordinato
        const initialPuzzle = [
            "    printf(\"Grande\");",
            "int main()",
            "    scanf(\"%d\", &numero);",
            "#include <stdio.h>",
            "    return 0;",
            "    if(numero>=10)",
            "{",
            "    int numero;",
            "}",
            "    else",
            "    printf(\"Piccolo\");",
            "    printf(\"inserire un numero\");"
        ]; 

        const puzzleContainer = document.getElementById('puzzle-container');
        const checkBtn = document.getElementById('check-btn');
        const resetBtn = document.getElementById('reset-btn');
        const feedbackMessage = document.getElementById('feedback-message');

        let draggedItem = null;

        // Funzione per creare e popolare il puzzle
        function renderPuzzle(commands) {
            puzzleContainer.innerHTML = '';
            feedbackMessage.style.display = 'none';

            commands.forEach(command => {
                const piece = document.createElement('div');
                piece.textContent = command;
                piece.className = 'puzzle-piece';
                piece.setAttribute('draggable', 'true');
                puzzleContainer.appendChild(piece);
            });

            addDragListeners();
        }

        // Aggiunge i listener per il trascinamento a tutti i pezzi
        function addDragListeners() {
            document.querySelectorAll('.puzzle-piece').forEach(piece => {
                // Drag Start
                piece.addEventListener('dragstart', (e) => {
                    draggedItem = piece;
                    setTimeout(() => piece.classList.add('dragging'), 0);
                    e.dataTransfer.effectAllowed = 'move';
                });

                // Drag End
                piece.addEventListener('dragend', () => {
                    draggedItem.classList.remove('dragging');
                    draggedItem = null;
                });

                // Drag Over
                piece.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                    if (piece !== draggedItem) {
                        const rect = piece.getBoundingClientRect();
                        const isAfter = e.clientY > rect.top + rect.height / 2;
                        
                        document.querySelectorAll('.puzzle-piece').forEach(p => p.classList.remove('drag-over'));
                        
                        piece.classList.add('drag-over');
                        piece.style.borderBottom = isAfter ? '2px solid #2ecc71' : '1px solid #bdc3c7';
                    }
                });

                // Drag Leave
                piece.addEventListener('dragleave', () => {
                    piece.classList.remove('drag-over');
                });
                
                // Drop
                piece.addEventListener('drop', (e) => {
                    e.preventDefault();
                    piece.classList.remove('drag-over');

                    if (draggedItem && draggedItem !== piece) {
                        const rect = piece.getBoundingClientRect();
                        const isAfter = e.clientY > rect.top + rect.height / 2;

                        if (isAfter) {
                            puzzleContainer.insertBefore(draggedItem, piece.nextSibling);
                        } else {
                            puzzleContainer.insertBefore(draggedItem, piece);
                        }
                    }
                });
            });
            
            // Gestisce il drop nel contenitore vuoto o alla fine
            puzzleContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                document.querySelectorAll('.puzzle-piece').forEach(p => p.classList.remove('drag-over'));
            });

            puzzleContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                if (e.target === puzzleContainer && draggedItem) {
                    puzzleContainer.appendChild(draggedItem);
                }
            });
        }

        // Funzione per controllare la soluzione
        function checkSolution() {
            const currentOrder = Array.from(puzzleContainer.children).map(piece => piece.textContent);
            
            const isCorrect = currentOrder.every((command, index) => command === correctOrder[index]);

            feedbackMessage.style.display = 'block';
            feedbackMessage.classList.remove('success', 'error');

            if (isCorrect) {
                feedbackMessage.classList.add('success');
                feedbackMessage.textContent = 'ðŸ¥³ Soluzione corretta! Il programma Ã¨ nell\'ordine giusto!';
            } else {
                feedbackMessage.classList.add('error');
                feedbackMessage.textContent = 'ðŸ˜• Soluzione errata. Riprova a riordinare le righe di codice.';
            }
        }

        // Funzione per resettare il puzzle
        function resetPuzzle() {
            const resetCommands = [...initialPuzzle];
            renderPuzzle(resetCommands);
            feedbackMessage.style.display = 'none';
        }

        // Aggiungi i listener ai pulsanti
        checkBtn.addEventListener('click', checkSolution);
        resetBtn.addEventListener('click', resetPuzzle);

        // Inizializza il puzzle al caricamento della pagina
        document.addEventListener('DOMContentLoaded', () => {
            renderPuzzle(initialPuzzle);
        });
    </script>
</body>
</html>